package scommons.websql.encoding

import scommons.nodejs._
import scommons.nodejs.test.TestSpec

class TupleEncodingSpec extends TestSpec {

  it should "generate TupleDecoders.scala" in {
    //given
    val dstFile = path.join(
      "encoding", "src", "main", "scala", "scommons", "websql", "encoding", "TupleDecoders.scala"
    )

    //when & then
    fs.writeFileSync(dstFile,
      s"""// DO NOT EDIT: generated by TupleEncodingSpec.scala
         |package scommons.websql.encoding
         |
         |trait TupleDecoders extends BaseEncodingDsl {
         |${(2 to 22).map(genTupleDecoder).mkString("")}
         |}
         |""".stripMargin)
  }
  
  it should "generate TupleOptDecoders.scala" in {
    //given
    val dstFile = path.join(
      "encoding", "src", "main", "scala", "scommons", "websql", "encoding", "TupleOptDecoders.scala"
    )

    //when & then
    fs.writeFileSync(dstFile,
      s"""// DO NOT EDIT: generated by TupleEncodingSpec.scala
         |package scommons.websql.encoding
         |
         |trait TupleOptDecoders extends BaseEncodingDsl {
         |${(2 to 22).map(genTupleOptDecoder).mkString("")}
         |}
         |""".stripMargin)
  }
  
  it should "generate TupleEncoders.scala" in {
    //given
    val dstFile = path.join(
      "encoding", "src", "main", "scala", "scommons", "websql", "encoding", "TupleEncoders.scala"
    )

    //when & then
    fs.writeFileSync(dstFile,
      s"""// DO NOT EDIT: generated by TupleEncodingSpec.scala
         |package scommons.websql.encoding
         |
         |trait TupleEncoders extends BaseEncodingDsl {
         |${(2 to 22).map(genTupleEncoder).mkString("")}
         |}
         |""".stripMargin)
  }
  
  private def genTupleDecoder(arity: Int): String = {
    val typeArgs = (1 to arity).foldLeft(new StringBuilder) { (buf, k) =>
      if (k > 1) buf ++= s", "
      buf ++= s"T$k"
    }
    
    val decoders = (1 to arity).foldLeft(new StringBuilder) { (buf, k) =>
      if (k > 1) buf ++= s", "
      buf ++= s"d$k: Decoder[T$k]"
    }
    
    val results = (1 to arity).foldLeft(new StringBuilder) { (buf, k) =>
      if (k > 1) buf ++= s",\n      ${"  " * (k - 1)}"
      buf ++= s"d$k(r.index, r)"
    }
    
    s"""
       |  implicit def tuple${arity}Decoder[$typeArgs](
       |    implicit $decoders
       |  ): Decoder[($typeArgs)] =
       |    WebSqlDecoder { (_: Index, r: ResultRow) =>
       |      ($results)
       |    }
       |""".stripMargin
  }

  private def genTupleOptDecoder(arity: Int): String = {
    val typeArgs = (1 to arity).foldLeft(new StringBuilder) { (buf, k) =>
      if (k > 1) buf ++= s", "
      buf ++= s"T$k"
    }
    
    s"""
       |  implicit def tuple${arity}OptDecoder[$typeArgs](
       |    implicit d: Decoder[($typeArgs)]
       |  ): Decoder[Option[($typeArgs)]] =
       |    WebSqlDecoder { (_: Index, r: ResultRow) =>
       |      if (r.isDefinedAt(r.index)) {
       |        Some(d(r.index, r))
       |      } else {
       |        r.skipIndices($arity)
       |        None
       |      }
       |    }
       |""".stripMargin
  }

  private def genTupleEncoder(arity: Int): String = {
    val typeArgs = (1 to arity).foldLeft(new StringBuilder) { (buf, k) =>
      if (k > 1) buf ++= s", "
      buf ++= s"T$k"
    }
    
    val encoders = (1 to arity).foldLeft(new StringBuilder) { (buf, k) =>
      if (k > 1) buf ++= s", "
      buf ++= s"e$k: Encoder[T$k]"
    }
    
    val results = (arity to 1 by -1).foldLeft(new StringBuilder) { (buf, k) =>
      if (k < arity) buf ++= s",\n      ${"  " * (arity - k)}"
      buf ++= s"e$k(-1, v._$k"
    } ++= s", row${")" * arity}"
    
    s"""
       |  implicit def tuple${arity}Encoder[$typeArgs](
       |    implicit $encoders
       |  ): Encoder[($typeArgs)] =
       |    WebSqlEncoder { (_: Index, v: ($typeArgs), row: PrepareRow) =>
       |      $results
       |    }
       |""".stripMargin
  }
}
